클래스와 변수
=

클래스를 생성한 뒤 사용하는 것이란
-

`java.util` 라이브러리에 위치한 클래스를 이용할 때의 잘못된 예시이다.

```
String useless = sc.next();
Scanner sc = new Scanner(System.in);
```

`Scanner` 객체를 사용하기 전에 객체를 사용하겠다는 선언이다. 객체참조변수인 `sc`를 이용할 수 없기 때문에 컴파일을 할 수 없다.

클래스의 생성과 생성자
-

클래스를 만들 때, 생성자 메서드에서 파라미터를 요구할 수 있다.

```
Scanner sc = new Scanner(System.in);
```

`Scanner` 클래스의 객체 생성시에 반드시 필요한 것은 데이터 스트림에 필요한 데이터의 `input`를 허용하는 것이다.

따라서 Scanner 클래스의 객체를 생성시에는 반드시 생성자 파라미터에 `System.in`을 넣어줘야 한다.

main 메소드와 객체 생성
-
Java의 규칙 중 하나는 main 메소드 `public static void main(String[] args)`라는 명령은 무조건 시작지점으로 시작된다. 

```
public static void main(String[] args) {

}
```

main 메서드 선언 시, `static`이 지정되어 있기 때문에 main 메소드는 항상 메모리에 탑재되어 있다.


객체의 메소드를 사용할 경우에 필요한 확인 요소
-

`Scanner` 객체를 사용시, 입력받는 데이터의 타입에 맞는 메소드를 사용해야한다.
다양한 방법을 사용할 수도 있지만, Scanner에서 제공되는 타입 중, 입력받은 타입

클래스 자체는 리턴이 없다 클래스에 있는 메소드를 사용하여 의도한 값을 리턴한다.
-

당연한 이야기일 수도 있지만, 알려주는 사람이 없음

```
int cc = Integer.parseInt(stringToInt);
String dd = Integer.toString(intToString);
```

위와 같은 예시를 자세히 찾아보면 Integer 클래스의 .parseInt 메서드, .toString을 이용하여 반환된 값을 대입하고 있다.

클래스를 호출한 뒤, 해당 클래스의 메소드의 값을 반환받아 값에 대입할 수 있다.

자주 사용하는 메서드의 경우 static을 선언하여 **메모리에 항시 적재해두면 객체를 생성하지 않고 바로 사용할 수 있다.**